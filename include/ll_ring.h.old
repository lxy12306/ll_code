#ifndef _LL_RING_H_
#define _LL_RING_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "../ring/ll_ring_core.h"

/**
 * Create a new ring named *name* in memory.
 *
 * This function uses ``memzone_reserve()`` to allocate memory. Then it
 * calls rte_ring_init() to initialize an empty ring.
 *
 * The new ring size is set to *count*, which must be a power of
 * two. Water marking is disabled by default. The real usable ring size
 * is *count-1* instead of *count* to differentiate a free ring from an
 * empty ring.
 *
 * The ring is added in LL_TAILQ_RING list.
 *
 * @param name
 *   The name of the ring.
 * @param count
 *   The size of the ring (must be a power of 2).
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   An OR of the following:
 *   - One of mutually exclusive flags that define producer behavior:
 *      - RING_F_SP_ENQ: If this flag is set, the default behavior when
 *        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
 *        is "single-producer".
 *      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when
 *        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
 *        is "multi-producer RTS mode".
 *      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when
 *        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
 *        is "multi-producer HTS mode".
 *     If none of these flags is set, then default "multi-producer"
 *     behavior is selected.
 *   - One of mutually exclusive flags that define consumer behavior:
 *      - RING_F_SC_DEQ: If this flag is set, the default behavior when
 *        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
 *        is "single-consumer". Otherwise, it is "multi-consumers".
 *      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when
 *        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
 *        is "multi-consumer RTS mode".
 *      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when
 *        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
 *        is "multi-consumer HTS mode".
 *     If none of these flags is set, then default "multi-consumer"
 *     behavior is selected.
 * @return
 *   On success, the pointer to the new allocated ring. NULL on error with
 *    rte_errno set appropriately. Possible errno values include:
 *    - E_LL_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_LL_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - count provided is not a power of 2
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
struct ll_ring* ll_ring_create(const char* name, unsigned int count,
	int socket_id, unsigned int flags);
/**
 * free ll_ring
 */
void ll_ring_free(struct ll_ring* r); 

/**
 * Retern the number of entries in a ring
 * 
 * @parma r
 *  A pointer to the ring structure
 * @return
 *  The number of entries in the ring 
 */
static inline unsigned
ll_ring_count(const struct ll_ring *r) {
	uint32_t prod_tail = r->prod.tail;
	uint32_t cons_tail = r->cons.tail;
	uint32_t count = (prod_tail - cons_tail) & r->mask;
	return (count > r->capacity): r->capacity: count;
}
/**
 * Retern the number of free entries in a ring
 * 
 * @parma r
 *  A pointer to the ring structure
 * @return
 *  The number of free entries in the ring 
 */
static inline unsigned
ll_ring_free_count(const struct ll_ring* r) {
	return r->capacity - ll_ring_count(r);
}

/**
 * Test if a ring is full 
 *
 * @parma r
 *  A pointer to the ring structure
 * @return
 *  -1 : The ring is full
 *   0 : The ring is not full
 */
static inline int
ll_ring_full(const struct ll_ring* r) {
	return  ll_ring_free_count(r) == 0;
}
/**
 * Dump the status of all rings on the console
 *
 * @param f
 *  A pointer to a file for output
 */

void ll_ring_list_dump(FILE *f);

#ifdef __cplusplus
}
#endif

#endif
